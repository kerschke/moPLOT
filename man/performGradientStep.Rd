% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/performGradientStep.R
\name{performGradientStep}
\alias{performGradientStep}
\title{Perform multi-objective gradient descent step.}
\usage{
performGradientStep(
  ind,
  fn,
  gradient.mat,
  scale.step = 0.5,
  prec.grad = 1e-06,
  prec.norm = 1e-06,
  prec.angle = 1e-04,
  check.data = TRUE
)
}
\arguments{
\item{ind}{\link{\code{\link{numeric}(d)}}\cr
d-dimensional individual.}

\item{scale.step}{\link{\code{\link{numeric}(1L)}}\cr
Scaling factor for the step size in the direction of the multi-objective gradient.
The default is \code{0.5}.}

\item{prec.grad}{\link{\code{\link{numeric}(1L)}}\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{check.data}{\link{\code{\link{logical}(1L)}}\cr
Should sanity checks be performed? The default is \code{TRUE}. Note that the checks
should only be turned off (e.g., for a slight speed up), if you are sure that you
provide the input data in the correct format.}

\item{fn1}{\link{\code{\link{function}}}\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{\link{\code{\link{function}}}\cr
The second objective used for computing the multi-objective gradient.}

\item{gradient.list}{\link{\code{\link{list}(p)}}\cr
A list with the single-objective gradients of the p objectives. Per default
each of the p elements of this list is NULL, implying that the respective
gradients will be approximated using \code{\link{estimateGradientBothDirections}}.}

\item{lower}{\link{\code{\link{numeric}(d)}}\cr
Vector of lower bounds.}

\item{upper}{\link{\code{\link{numeric}(d)}}\cr
Vector of upper bounds.}
}
\value{
\link{\code{\link{numeric}}(d) | \code{\link{NULL}}}\cr
Returns \code{NULL} if \code{ind} is a local efficient point. Otherwise a numeric
vector of length \code{d} will be returned, which shows the result of a downhill
step in the direction of the multi-objective gradient.
}
\description{
Computes the bi-objective gradient for the bi-objective function \code{fn}
in position \code{ind}. The bi-objective gradient is the combined vector of the
two single gradients. Note that the step size depends on the length of the combined
gradient vector and thus automatically decreases when approaching an efficient set.
}
\note{
ATTENTION: Only turn off the sanity checks (\code{check.data = FALSE}),
if you can ensure that all input parameters are provided in the correct format.
}
\examples{
# Define two single-objective test problems:
fn1 = function(x) sum((x - c(0.2, 1))^2)
fn2 = function(x) sum(x)
fn = function(x) return(c(fn1(x), fn2(x)))

# Perform a gradient step:
performGradientStep(c(0.3, 0.5), fn)

# Here, we have found the optimum of fn1:
performGradientStep(c(0.2, 1), fn)
}
