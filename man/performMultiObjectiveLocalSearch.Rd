% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/performMultiObjectiveLocalSearch.R
\name{performMultiObjectiveLocalSearch}
\alias{performMultiObjectiveLocalSearch}
\title{Performs a multi-objective local search.}
\usage{
performMultiObjectiveLocalSearch(
  x1,
  x2,
  x3,
  fn,
  prec.grad = 1e-06,
  prec.norm = 1e-06,
  prec.angle = 1e-04,
  scale.step = 0.5,
  max.steps = 1000L
)
}
\arguments{
\item{x1}{\link{\code{\link{numeric}(d)}}\cr
d-dimensional individual located on one side of the (bi-objective) optimum.}

\item{x2}{\link{\code{\link{numeric}(d)}}\cr
d-dimensional individual located on the opposite side (w.r.t. \code{x1}) of
the (bi-objective) optimum.}

\item{x3}{\link{\code{\link{numeric}(d)}}\cr
d-dimensional individual located such that the vector from \code{x2} to \code{x3}
points in the opposite direction of the vector from \code{x1} to \code{x2}.}

\item{prec.grad}{\link{\code{\link{numeric}(1L)}}\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{scale.step}{\link{\code{\link{numeric}(1L)}}\cr
Scaling factor for the step size in the direction of the multi-objective gradient.
The default is \code{0.5}.}

\item{max.steps}{\link{\code{\link{integer}(1L)}}
Maximum number of local search steps to reach an optimum. The default is \code{1000L}.}

\item{fn1}{\link{\code{\link{function}}}\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{\link{\code{\link{function}}}\cr
The second objective used for computing the multi-objective gradient.}

\item{lower}{\link{\code{\link{numeric}(d)}}\cr
Vector of lower bounds.}

\item{upper}{\link{\code{\link{numeric}(d)}}\cr
Vector of upper bounds.}
}
\value{
\link{\code{\link{list}(5L)}}\cr
List containing the matrix of points, which were visited in the course
of the optimization, another matrix providing the number of performed
function evaluations, two vectors providing the single-objective gradients
of the last individual and a logical flag, indicating whether the optimizer
found a local efficient point.
}
\description{
Given three initial points \code{x1}, \code{x2} and \code{x3}, of which is known that
the angle between \code{x2 - x1} and \code{x3 - x2} is larger than 90 degree (i.e.,
they point in opposite directions), this optimizer tries to find a local effient
point that has to be located betwen \code{x1} and \code{x2}.
}
\examples{
# Define two single-objective test problems:
fn1 = function(x) sum((x - c(2, 0))^2)
fn2 = function(x) sum((x - c(0, 1))^2)
fn = function(x) return(fn1(x), fn2(x))

# Visualize locally efficient set, i.e., the "area" where we ideally want to find a point:
plot(c(2, 0), c(0, 1), type = "o", pch = 19,
  xlab = expression(x[1]), ylab = expression(x[2]), las = 1, asp = 1)
text(2, 0, "Optimum of fn1", pos = 2, offset = 1.5)
text(0, 1, "Optimum of fn2", pos = 4, offset = 1.5)

# Place two points x1 and x2 on opposite sides of the bi-objective optimum:
x1 = c(1, 1)
x2 = c(0.5, 0)
x3 = c(0.8, 0.2)
points(rbind(x1, x2, x3), pch = 19, type = "o", lty = "dotted")
text(rbind(x1, x2, x3), labels = c("x1", "x2", "x3"), pos = 4)

# Optimize using weighted bisection optimization:
result = performMultiObjectiveLocalSearch(x1 = x1, x2 = x2, x3 = x3,
  fn = fn, lower = c(0, 0), upper = c(2, 1))
opt.path = result$opt.path

# Visualize the optimization path:
points(opt.path)

# Highlight the found local efficient point (= local optimum w.r.t. both objectives):
n = nrow(opt.path)
points(opt.path[n, 1], opt.path[n, 2], pch = 4, col = "red", cex = 2)
text(opt.path[n, 1], opt.path[n, 2], "Found Local Efficient Point", pos = 4, offset = 1.5)
}
