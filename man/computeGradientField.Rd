% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/computeGradientField.R
\name{computeGradientField}
\alias{computeGradientField}
\title{Compute the multi-objective gradient vector for a set of points.}
\usage{
computeGradientField(
  points,
  fn,
  prec.grad = 1e-06,
  prec.norm = 1e-06,
  prec.angle = 1e-04,
  parallelize = FALSE,
  impute.boundary = TRUE,
  lower = NULL,
  upper = NULL
)
}
\arguments{
\item{points}{\link{\code{\link{matrix}}}\cr
Matrix of points, for which the multi-objective gradient should be computed.
Each row of the matrix will be considered as a separate point, thus the number
of rows corresponds to the number of observations and the number of columns
to the dimensionality of the search space.}

\item{prec.grad}{\link{\code{\link{numeric}(1L)}}\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{prec.norm}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold when normalizing a vector. That is, every element of the vector,
whose absolute value is below this threshold, will be replaced by 0.
The default is \code{1e-6}.}

\item{prec.angle}{\link{\code{\link{numeric}(1L)}}\cr
Precision threshold used for comparing whether the angle (in degree) between two
vectors is zero. The default is \code{1e-4}.}

\item{parallelize}{\link{\code{\link{logical}(1L)}}\cr
Should the computation of the gradient vectors be parallelized (with \code{parallel::mclapply})?
The default is \code{FALSE}.}

\item{lower}{\link{\code{\link{numeric}(d)}}\cr
Vector of lower bounds.}

\item{upper}{\link{\code{\link{numeric}(d)}}\cr
Vector of upper bounds.}

\item{fn1}{\link{\code{\link{function}}}\cr
The first objective used for computing the multi-objective gradient.}

\item{fn2}{\link{\code{\link{function}}}\cr
The second objective used for computing the multi-objective gradient.}

\item{fn3}{\link{\code{\link{function}}}\cr
The third objective used for computing the multi-objective gradient. If not provided
(\code{fn3 = NULL}), the gradient field will only consider fn1 and fn2.}

\item{scale.step}{\link{\code{\link{numeric}(1L)}}\cr
Scaling factor for the step size in the direction of the multi-objective gradient.
The default is \code{0.5}.}
}
\value{
\link{\code{\link{matrix}}}\cr
Returns \code{matrix} of multi-objective gradients. The i-th row of the matrix
contains the multi-objective gradient vector of the i-th observation (= row)
of the input matrix \code{points}.
}
\description{
Computes the multi-objective gradients for a matrix of \code{points}.
}
\examples{
# Define bi-objective test problems:
fn = function(x) c(sum((x - c(0.2, 1))^2), sum(x))

# Create a grid of points, for which the gradients should be computed:
points = expand.grid(x1 = seq(0, 1, 0.01), x2 = seq(0, 1, 0.05))
gradient.field = computeGradientField(points, fn)
}
