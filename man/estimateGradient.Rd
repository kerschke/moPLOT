% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimateGradient.R
\name{estimateGradient}
\alias{estimateGradient}
\alias{estimateGradientSingleDirection}
\alias{estimateGradientBothDirections}
\title{Approximate gradient of a single-objective function.}
\usage{
estimateGradientSingleDirection(
  fn,
  ind,
  side = NULL,
  prec.grad = 1e-06,
  check.data = TRUE,
  lower = NULL,
  upper = NULL,
  ...
)

estimateGradientBothDirections(
  fn,
  ind,
  prec.grad = 1e-04,
  check.data = TRUE,
  lower = NULL,
  upper = NULL,
  ...
)
}
\arguments{
\item{fn}{[\code{\link[=function]{function()}}]\cr
Single-objective function, whose gradient will be approximated.}

\item{ind}{\link{\code{\link{numeric}(d)}}\cr
d-dimensional individual.}

\item{side}{[\verb{[logical](d)}]\cr
Logical vector of the same length as \code{x}, stating per element whether to
approximate the gradient into the positive (\code{TRUE}) or negative (\code{FALSE})
direction of \code{x}. The default is \code{rep(TRUE, length(x))}.}

\item{prec.grad}{\link{\code{\link{numeric}(1L)}}\cr
Precision value (= step size) used for approximating the gradient. The default is \code{1e-6}.}

\item{check.data}{\link{\code{\link{logical}(1L)}}\cr
Should sanity checks be performed? The default is \code{TRUE}. Note that the checks
should only be turned off (e.g., for a slight speed up), if you are sure that you
provide the input data in the correct format.}

\item{lower}{\link{\code{\link{numeric}(d)}}\cr
Vector of lower bounds.}

\item{upper}{\link{\code{\link{numeric}(d)}}\cr
Vector of upper bounds.}

\item{...}{Further arguments to be passed to \code{fn}.}
}
\value{
[\verb{[numeric](d)}]
}
\description{
\code{estimateGradient} approximates the gradient of a single-objective function
\code{fn} in position \code{x} based on small changes in one direction per
dimension of \code{x}.
\deqn{\nabla f(\mathbf{x}) = \frac{f(\mathbf{x} + \boldsymbol{\varepsilon}) - f(\mathbf{x})}{||\boldsymbol{\varepsilon}||}}
The gradient approximation is performed separately for each dimension of the search space.
That is, the i-th element of the gradient results from a slight step (step size: \code{prec.grad})
of the i-th element of \code{x}, while all remaining elements of \code{x} are not altered.\cr

In contrast to the aforementioned function, \code{estimateGradientBothDirections}
performs a small step in both directions (of the i-th element) of \code{x}.
\deqn{\nabla f(\mathbf{x}) = \frac{f(\mathbf{x} + \boldsymbol{\varepsilon}) - f(\mathbf{x} - \boldsymbol{\varepsilon})}{2 \cdot ||\boldsymbol{\varepsilon}||}}
}
\note{
This function basically is a slightly modified version of
\code{numDeriv::grad(..., method = "simple")} and was mainly developed for
internal usage to have a speed up over the aforementioned version. However,
this speed up will only have an effect, if you call this function very
frequently and if you turn off the sanity checks.\cr

ATTENTION: Only turn off the sanity checks (\code{check.data = FALSE}),
if you can ensure that all input parameters are provided in the correct format.
}
\examples{
fn = function(x) sum(x^2)
estimateGradientSingleDirection(fn, c(0.3, 0.5))
estimateGradientSingleDirection(fn, c(0.3, 0.5), side = rep(FALSE, 2L))
estimateGradientBothDirections(fn, c(0.3, 0.5))
}
